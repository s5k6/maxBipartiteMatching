<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>MaxMatching.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>

<div style="text-align: center">
<h1>Maximum bipartite matching: 24 lines</h1>
<p style="font-size: normal">Copyright: <a href="http://stefan-klinger.de/">© Stefan Klinger 2012</a></br>License: <a href="http://www.gnu.org/licenses/agpl-3.0.html">GNU Affero General Public License, Version 3</a></p>
</div>

<p>This <a href="www.haskell.org">Haskell</a> module finds
a <a href="https://en.wikipedia.org/wiki/Maximum_matching#Maximum_matchings_in_bipartite_graphs">maximum
cardinality matching on a bipartite graph</a>, using
an <a href="https://en.wikipedia.org/wiki/Hopcroft-Karp_algorithm">augmenting
path algorithm</a>.  It's only 24 lines of code, and it's pure.  For all
that, it seems surprisingly efficient, but it's not as good
as <a href="https://en.wikipedia.org/wiki/Hopcroft-Karp_algorithm">Hopcroft–Karp</a>.</p>

<hr\>

<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>MaxMatching</span> <span class='hs-layout'>(</span> <span class='hs-varid'>matching</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
</pre>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>M</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>S</span>
</pre>

<h2>Basics</h2>

<p>A bipartite graph has “left” and “right” nodes, we assume the types α
and β for them.  Each edge then is an (α,β) pair, i.e., there are no
edges between nodes on the same side.</p>

<p>A “matching” is a subset of the edges, so that each node is incident to
at most one edge that is in the matching.  We are looking for a matching
that contains as many edges as possible.  With respect to a fixed
matching, an edge is called “matched” iff it is part of the matching.  A
node is called “free” iff it is not incident to any matched edge.</p>

<p>An “augmenting path” contains no cycles, starts at a free α-node,
terminates at a free β-node, and strictly alternately traverses
unmatched and matched edges.</p>

<p>The algo is based on the idea of repeatedly finding an augmenting path
with respect to a current matching, starting from the empty matching,
similar to <a href="https://en.wikipedia.org/wiki/Hopcroft-Karp_algorithm">Hopcroft–Karp</a>.  When an augmenting path is found, all of
its matched edges become unmatched, and vice versa, thus incrementing
the matching's size by one.</p>

<h2>Implementation</h2>

<p>The input graph is of type <code>Set (a,b)</code> which implies being bipartite and
simple.  It also denies isolated nodes, but they cannot be matched
anyways.</p>

<p>When looking for an augmenting path, travelling “right” to a β-node, is
always via an unmatched edge, and travelling “left” to an α-node is
always via a matched edge.  Exactly the first and last node of an
augmenting path are free, the inner nodes are not.  Since a β-node can
have at most one matched edge, it is sufficient to store the matching in
a map of type <code>Map b a</code>, <em>i.e.</em>, backwards.  The invariant is being a
proper matching, <em>i.e.</em>, being injective.</p>

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>matching</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>matching</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>opt</span> <span class='hs-layout'>(</span><span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>keys</span> <span class='hs-varid'>fwd</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>fwd</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>where</span>
</pre>

<p>Travelling right, we can choose any unmatched edge.  To this end, the
entire graph is maintained as a “forward mapping” of type <code>Map a
[b]</code>, listing all β-nodes adjacent to an α-node.</p>

<pre><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>fwd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>insertWith</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span> <span class='hs-varop'>$</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>toList</span> <span class='hs-varid'>g</span>
</pre>

<p>Given two lists of (initially all) free and (initially no) failed nodes,
the forward mapping, and an (initially empty) matching, the optimizer
function…</p>

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>opt</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span>
</pre>

<p>…repeatedly calls <code>right</code> on each free α-node, <em>i.e.</em>, starts a path
search from <code>x</code>, hoping to get a better matching back.</p>

<p>If no better matching is found, then <code>x</code> is is set aside as a failed
node for reconsideration in later iterations.  Otherwise, <code>x</code> is part of
the matching an removed from the list of free nodes.  Also, the failed
nodes set aside previously are appended to the free nodes, since they
may lead to an augmenting path with the new matching.</p>

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>opt</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>free</span><span class='hs-layout'>,</span><span class='hs-varid'>failed</span><span class='hs-layout'>)</span> <span class='hs-varid'>fwd</span> <span class='hs-varid'>mat</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>either</span> <span class='hs-layout'>(</span><span class='hs-varid'>flip</span> <span class='hs-layout'>(</span><span class='hs-varid'>opt</span> <span class='hs-layout'>(</span><span class='hs-varid'>free</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>failed</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>mat</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>opt</span> <span class='hs-layout'>(</span><span class='hs-varid'>free</span><span class='hs-varop'>++</span><span class='hs-varid'>failed</span><span class='hs-layout'>,</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>fwd</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>       <span class='hs-varop'>$</span> <span class='hs-varid'>right</span> <span class='hs-varid'>fwd</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>x</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>where</span>
</pre>

<p><code>right</code> returns Either Right a better matching if an augmenting path
starting at <code>x</code> was found, or Left a reduced forward mapping otherwise.
The rationale is, that if no augmenting path was found, then all α-nodes
traversed on the quest can be omitted from further searches until the
matching is modified: They cannot become part of any augmenting path.</p>

<p>Note, that <code>opt</code> always applies <code>right</code> to a free node, and the complete
original forward mapping, while <code>left</code> always applies <code>right</code> to a
non-free node and a reduced forward mapping.  The argument <code>path</code>
accumulates the augmenting path.</p>

<p>The remaining forward mapping <code>rem</code> yields a list of β-nodes that can be
reached from <code>x</code>.  We try to walk left from these, without ever going
back to <code>x</code>, which is why it's deleted from <code>rem</code>.</p>

<pre><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>right</span> <span class='hs-varid'>rem</span> <span class='hs-varid'>path</span> <span class='hs-varid'>x</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>rem</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>left</span> <span class='hs-varop'>$</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>delete</span> <span class='hs-varid'>x</span> <span class='hs-varid'>rem</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>lookup</span> <span class='hs-varid'>x</span> <span class='hs-varid'>rem</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>left</span> <span class='hs-varid'>rem</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>rem</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>left</span> <span class='hs-varid'>rem</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>e</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>maybe</span> <span class='hs-varid'>n</span> <span class='hs-varid'>j</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- for better readability</span>
</pre>

<p>For the first reacheble β-node <code>y</code>, we check wheter it is free, <em>i.e.</em>,
not in the matching <code>mat</code>.</p>

<pre><span class='hs-varop'>&gt;</span>               <span class='hs-layout'>(</span><span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>lookup</span> <span class='hs-varid'>y</span> <span class='hs-varid'>mat</span><span class='hs-layout'>)</span>
</pre>

<p>If so, then <code>path'</code> is used to augment the matching.  We need to augment
anyways, so we can do this here and return a new matching instead of
returning a path and augment later.  Also, we don't collect multiple
paths before augmentation, because that would require to protect the
still-free β-node <code>y</code> from being used in another augmenting path.  Enjoy
this:</p>

<pre><span class='hs-varop'>&gt;</span>               <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varop'>$</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>uncurry</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flip</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>insert</span><span class='hs-layout'>)</span> <span class='hs-varid'>mat</span> <span class='hs-varid'>path'</span><span class='hs-layout'>)</span>
</pre>

<p>However, if <code>y</code> is not free, we try to continue where the matched edge
leads to, descending <code>right</code> from there.  If that fails, we try one of
the remaining <code>ys</code>, recursing <code>left</code>.</p>

<pre><span class='hs-varop'>&gt;</span>               <span class='hs-layout'>(</span><span class='hs-varid'>either</span> <span class='hs-layout'>(</span><span class='hs-varid'>flip</span> <span class='hs-varid'>left</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span> <span class='hs-varop'>.</span> <span class='hs-varid'>right</span> <span class='hs-varid'>rem</span> <span class='hs-varid'>path'</span><span class='hs-layout'>)</span>
</pre>
<pre><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>where</span>
</pre>

<p>The new path is made up of the currently last edge (x,y) and what we
have seen on the DFS so far,</p>

<pre><span class='hs-varop'>&gt;</span>             <span class='hs-varid'>path'</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>path</span>
</pre>

<p>Finally, when no more improvements are found for any potential left
node, <em>i.e.</em>, all free α-nodes failed, then the current matching is
returned.</p>

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>opt</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span><span class='hs-varid'>failed</span><span class='hs-layout'>)</span> <span class='hs-varid'>fwd</span> <span class='hs-varid'>mat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mat</span>
</pre>

<hr/>

<h2>Testing</h2>

<p>The following charts compare elapsed real time, and maximum resident
set size of the process against the number of nodes, edges, and the size
of the matching.  The data for my implementation is plotted in green,
the data for FGL's MaxFlow in red.  Negative values indicate “did not
finish within 30 seconds”.</p>

<p>Both algorithms are run on the same graph, and the size of the
matching is compared with the capacity of the flow.  The graphs are
created randomly, the number of nodes is limited, as well as the maximum
ratio of left vs. right nodes.</p>

<h3>Small graphs</h3>

<p>Node count 10 to 100, min. ratio 3</p>

<table width="100%">
<tr>
  <th>&nbsp;</th>
  <th>no. nodes</th>
  <th>no. edges</th>
  <th>size matching</th>
</tr>
<tr>
  <th>time</th>
  <td><a href="log-10-100-3/time_nodes.png"><img width="200px" src="log-10-100-3/small_time_nodes.png"/></a></td>
  <td><a href="log-10-100-3/time_edges.png"><img width="200px" src="log-10-100-3/small_time_edges.png"/></a></td>
  <td><a href="log-10-100-3/time_matches.png"><img width="200px" src="log-10-100-3/small_time_matches.png"/></a></td>
</tr>
<tr>
  <th>memory</th>
  <td><a href="log-10-100-3/mem_nodes.png"><img width="200px" src="log-10-100-3/small_mem_nodes.png"/></a></td>
  <td><a href="log-10-100-3/mem_edges.png"><img width="200px" src="log-10-100-3/small_mem_edges.png"/></a></td>
  <td><a href="log-10-100-3/mem_matches.png"><img width="200px" src="log-10-100-3/small_mem_matches.png"/></a></td>
</tr>
</table>


<h3>Only my implementation</h3>

<p>To get a better impression about how it scales, not competing with FGL's MaxFlow.  Node count 10 to 500, min. ratio 1</p>

<table width="100%">
<tr>
  <th>&nbsp;</th>
  <th>no. nodes</th>
  <th>no. edges</th>
  <th>size matching</th>
</tr>
<tr>
  <th>time</th>
  <td><a href="log-10-500-1/time_nodes.png"><img width="200px" src="log-10-500-1/small_time_nodes.png"/></a></td>
  <td><a href="log-10-500-1/time_edges.png"><img width="200px" src="log-10-500-1/small_time_edges.png"/></a></td>
  <td><a href="log-10-500-1/time_matches.png"><img width="200px" src="log-10-500-1/small_time_matches.png"/></a></td>
</tr>
<tr>
  <th>memory</th>
  <td><a href="log-10-500-1/mem_nodes.png"><img width="200px" src="log-10-500-1/small_mem_nodes.png"/></a></td>
  <td><a href="log-10-500-1/mem_edges.png"><img width="200px" src="log-10-500-1/small_mem_edges.png"/></a></td>
  <td><a href="log-10-500-1/mem_matches.png"><img width="200px" src="log-10-500-1/small_mem_matches.png"/></a></td>
</tr>
</table>

</body>
</html>
